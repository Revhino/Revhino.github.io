<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>NowCoder-冥土追魂</title>
      <link href="//NowCoder-%E5%86%A5%E5%9C%9F%E8%BF%BD%E9%AD%82/"/>
      <url>//NowCoder-%E5%86%A5%E5%9C%9F%E8%BF%BD%E9%AD%82/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.nowcoder.com/acm/contest/212/B" target="_blank" rel="noopener">NowCoder-冥土追魂</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>有一个 <script type="math/tex">n * m \ (n, \ m <= 1000)</script> 的整数组成的矩阵。</p><p>一次操作将取走一行里最大的数，操作 <script type="math/tex">k \ (k <= n * m)</script> 次。</p><p>最小化取走的数的和。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><code>cpp</code></p><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>就差一点点。</li></ul>]]></content>
      
      <categories>
          
          <category> NowCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乱搞 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LGOJ3398-仓鼠找sugar</title>
      <link href="//LGOJ3398-%E4%BB%93%E9%BC%A0%E6%89%BEsugar/"/>
      <url>//LGOJ3398-%E4%BB%93%E9%BC%A0%E6%89%BEsugar/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/3398" target="_blank" rel="noopener">LGOJ3398-仓鼠找sugar</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>给定一棵 <script type="math/tex">n \ (n <= 100000)</script> 个节点的树，以及 <script type="math/tex">q \ (q <= 100000)</script> 个询问树上两条简单路径是否有交。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h4><p>简单的求出两个起点和两个终点路径的和。<br>与两条简单路径大小比较。<br>在纸上乱搞出来的，不会证。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h3 id="LCA-1"><a href="#LCA-1" class="headerlink" title="LCA"></a>LCA</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">1e5</span> + <span class="number">10</span>, kmax_int = INT_MAX, kmod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, next;</span><br><span class="line">&#125; edges[kmax_num * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, head[kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">  edges[++cnt] = (Edge) &#123;v, head[u]&#125;;</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">  edges[++cnt] = (Edge) &#123;u, head[v]&#125;;</span><br><span class="line">  head[v] = cnt;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[kmax_num];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">33</span>][kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GetDepth</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, REG <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">  dep[u] = depth;</span><br><span class="line">  <span class="keyword">for</span>(REG <span class="keyword">int</span> i = head[u]; i; i = edges[i].next)  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!dep[edges[i].v])  GetDepth(edges[i].v, depth + <span class="number">1</span>), f[<span class="number">0</span>][edges[i].v] = u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lg[kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">  FOR(i,<span class="number">2</span>,kmax_num) lg[i] = lg[i - <span class="number">1</span>] + (<span class="number">1</span> &lt;&lt; lg[i - <span class="number">1</span>] + <span class="number">1</span> == i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(REG <span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= n; ++i)  &#123;</span><br><span class="line">    For(h,<span class="number">1</span>,n)  f[i][h] = f[i - <span class="number">1</span>][f[i - <span class="number">1</span>][h]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(REG <span class="keyword">int</span> x, REG <span class="keyword">int</span> y)</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[x] &lt; dep[y]) <span class="built_in">std</span>::swap(x, y);</span><br><span class="line">  <span class="keyword">while</span>(dep[x] != dep[y])</span><br><span class="line">    x = f[lg[dep[x] - dep[y]]][x];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(x == y)  <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(REG <span class="keyword">int</span> i = lg[dep[x]]; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="keyword">if</span>(f[i][x] != f[i][y])</span><br><span class="line">      x = f[i][x], y = f[i][y];</span><br><span class="line">  <span class="keyword">return</span> f[<span class="number">0</span>][x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetDist</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span>  </span>&#123;</span><br><span class="line">  REG <span class="keyword">int</span> anc = LCA(x, y);</span><br><span class="line">  <span class="keyword">return</span> dep[x] + dep[y] - (dep[anc] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  FOR(i,<span class="number">1</span>,n)  &#123;</span><br><span class="line">    AIOS::file_io &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    AddEdge(u, v);</span><br><span class="line">  &#125;</span><br><span class="line">  GetDepth(<span class="number">1</span>, <span class="number">1</span>);  Init();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">  For(i,<span class="number">1</span>,q)  &#123;</span><br><span class="line">    AIOS::file_io &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    <span class="keyword">if</span>(GetDist(a, b) + GetDist(c, d) &gt;= GetDist(a, c) + GetDist(b, d))  <span class="built_in">puts</span>(<span class="string">"Y"</span>);</span><br><span class="line">    <span class="keyword">else</span>  <span class="built_in">puts</span>(<span class="string">"N"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>正确性不会证明（逃）。</li></ul>]]></content>
      
      <categories>
          
          <category> LGOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[ZJOI2007] 棋盘制作</title>
      <link href="//ZJOI2007-%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C/"/>
      <url>//ZJOI2007-%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/1196" target="_blank" rel="noopener">[ZJOI2007]棋盘制作</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>给定一个长度为 <script type="math/tex">n \ (n <= 2000) \ * \ m \ (m <= 2000)</script> 的矩形，求黑白相间的最大正方形和矩形。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>主要问题是把黑白相间的格子转换成全黑格。<br>注意到黑白相间，所以对不相邻的格子取反即可。<br>这样就转换成最大化子矩形问题。<br>注意这里并没有严格意义上的障碍点，所以要以黑和白为障碍点各跑一次。</p><h4 id="最大化子矩形"><a href="#最大化子矩形" class="headerlink" title="最大化子矩形"></a>最大化子矩形</h4><p>模板。<del>（摸你赛的时候我还不会</del><br>时间复杂度： <script type="math/tex">O(n^{2})</script> 。<br>预期得分： <script type="math/tex">(100)</script> 。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">2e3</span> + <span class="number">10</span>, kmax_int = INT_MAX, kmod = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[kmax_num][kmax_num], t[kmax_num], l[kmax_num], r[kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">int</span> x, y;</span><br><span class="line">  For(i,<span class="number">1</span>,n)  For(h,<span class="number">1</span>,m)  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; f[i][h];</span><br><span class="line">    <span class="keyword">if</span>(!((i + h) % <span class="number">2</span>))  f[i][h] = !f[i][h];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  For(i,<span class="number">1</span>,m)  r[i] = m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">char</span> tem;</span><br><span class="line">  REG <span class="keyword">int</span> num, ans1 = <span class="number">0</span>, ans2;</span><br><span class="line">  For(i,<span class="number">1</span>,n)  &#123;</span><br><span class="line">    For(h,<span class="number">1</span>,m)  &#123;</span><br><span class="line">      t[h] = !f[i][h] ? t[h] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    For(h,<span class="number">1</span>,m)</span><br><span class="line">      <span class="keyword">if</span>(!f[i][h])    l[h] = <span class="built_in">std</span>::max(l[h], num);</span><br><span class="line">      <span class="keyword">else</span>        l[h] = <span class="number">0</span>, num = h;</span><br><span class="line"></span><br><span class="line">    num = m+ <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(REG <span class="keyword">int</span> h = m; h; --h)</span><br><span class="line">      <span class="keyword">if</span>(!f[i][h])    r[h] = <span class="built_in">std</span>::min(r[h], num);</span><br><span class="line">      <span class="keyword">else</span>        r[h] = m + <span class="number">1</span>, num = h;</span><br><span class="line"></span><br><span class="line">    For(h,<span class="number">1</span>,m)</span><br><span class="line">      ans1 = <span class="built_in">std</span>::max(ans1, (r[h] - l[h] - <span class="number">1</span>) * t[h]),</span><br><span class="line">      ans2 = <span class="built_in">std</span>::max(ans2, <span class="built_in">std</span>::min(r[h] - l[h] - <span class="number">1</span>, t[h]) * <span class="built_in">std</span>::min(r[h] - l[h] - <span class="number">1</span>, t[h]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line">  <span class="built_in">memset</span>(l, <span class="number">0</span>, <span class="keyword">sizeof</span>(l));</span><br><span class="line">  <span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="keyword">sizeof</span>(r));</span><br><span class="line"></span><br><span class="line">  For(i,<span class="number">1</span>,m)  r[i] = m + <span class="number">1</span>;</span><br><span class="line">  For(i,<span class="number">1</span>,n)  &#123;</span><br><span class="line">    For(h,<span class="number">1</span>,m)  &#123;</span><br><span class="line">        t[h] = f[i][h] ? t[h] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    For(h,<span class="number">1</span>,m)</span><br><span class="line">      <span class="keyword">if</span>(f[i][h])    l[h] = <span class="built_in">std</span>::max(l[h], num);</span><br><span class="line">      <span class="keyword">else</span>        l[h] = <span class="number">0</span>, num = h;</span><br><span class="line"></span><br><span class="line">    num = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(REG <span class="keyword">int</span> h = m; h; --h)</span><br><span class="line">      <span class="keyword">if</span>(f[i][h])    r[h] = <span class="built_in">std</span>::min(r[h], num);</span><br><span class="line">      <span class="keyword">else</span>        r[h] = m + <span class="number">1</span>, num = h;</span><br><span class="line"></span><br><span class="line">    For(h,<span class="number">1</span>,m)</span><br><span class="line">      ans1 = <span class="built_in">std</span>::max(ans1, (r[h] - l[h] - <span class="number">1</span>) * t[h]),</span><br><span class="line">      ans2 = <span class="built_in">std</span>::max(ans2, <span class="built_in">std</span>::min(r[h] - l[h] - <span class="number">1</span>, t[h]) * <span class="built_in">std</span>::min(r[h] - l[h] - <span class="number">1</span>, t[h]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>, ans2, ans1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>三倍经验：<a href="https://www.luogu.org/problemnew/show/P4147" target="_blank" rel="noopener">玉蟾宫</a>，<a href="https://www.luogu.org/problemnew/show/P2701" target="_blank" rel="noopener">[USACO5.3]巨大的牛棚Big Barn</a>。</li></ul>]]></content>
      
      <categories>
          
          <category> 各省省选 </category>
          
          <category> ZJOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最大化子矩形 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[CTSC2014] 企鹅QQ</title>
      <link href="//CTSC2014-%E4%BC%81%E9%B9%85QQ/"/>
      <url>//CTSC2014-%E4%BC%81%E9%B9%85QQ/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/4503" target="_blank" rel="noopener">[CTSC2014]企鹅QQ</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>给定 <script type="math/tex">n \ (n <= 3e4)</script> 个长度为 <script type="math/tex">l \ (l <= 2e2)</script> 的字符串，求有多少对字符串等长且恰好只有一位不同。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很明显这长度就是哈希<del>（因为字符串我只会哈希</del><br>这道和某<del>毒瘤czl的</del>题很像啊。</p><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>枚举删除的位置，<script type="math/tex">hash</script>减掉即可。<br>然后排序统计答案。<br>时间复杂度： $O(l \ * \ n \ logn)$ 。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">3e4</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, l, s;</span><br><span class="line"><span class="keyword">char</span> c[kmax_num][<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> has[kmax_num], mod[kmax_num], mod_pow[<span class="number">201</span>], bas = <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">" %d %d %d"</span>, &amp;n, &amp;l, &amp;s);</span><br><span class="line">  For(i,<span class="number">1</span>,n)  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">" %s"</span>, c[i] + <span class="number">1</span>);</span><br><span class="line">    For(h,<span class="number">1</span>,l)  has[i] = has[i] * bas + c[i][h];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mod_pow[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  For(i,<span class="number">1</span>,l)  mod_pow[i] = mod_pow[i - <span class="number">1</span>] * bas;</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  For(i,<span class="number">1</span>,l)  &#123;</span><br><span class="line">    For(h,<span class="number">1</span>,n)  &#123;</span><br><span class="line">      mod[h] = has[h] - mod_pow[l - i] * c[h][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(mod + <span class="number">1</span>, mod + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    REG <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    FOR(h,<span class="number">1</span>,n)  &#123;</span><br><span class="line">      <span class="keyword">if</span>(mod[h] == mod[h + <span class="number">1</span>]) ++cnt;</span><br><span class="line">      <span class="keyword">else</span>    &#123;</span><br><span class="line">        ans += cnt * (cnt - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += cnt * (cnt - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>这里使用 <script type="math/tex">unsigned long long</script> 自然溢出。</li><li>基数 <script type="math/tex">bas</script> 要是被卡可以多换几个质数，如：（<script type="math/tex">19260817</script>）。</li></ul>]]></content>
      
      <categories>
          
          <category> CTSC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[SHOI2009] 会场预约</title>
      <link href="//SHOI2009-%E4%BC%9A%E5%9C%BA%E9%A2%84%E7%BA%A6/"/>
      <url>//SHOI2009-%E4%BC%9A%E5%9C%BA%E9%A2%84%E7%BA%A6/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/2161" target="_blank" rel="noopener">[SHOI2009]会场预约</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>编写一个数据结构支持 <script type="math/tex">2</script> 种 <script type="math/tex">n \ (n <= 200000)</script> 次操作。</p><ul><li>删除与 <script type="math/tex">(begin \ , \  end)</script> 有交集的区间，插入并输出删除数。</li><li>查询区间数。</li></ul><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="std-set"><a href="#std-set" class="headerlink" title="std::set"></a>std::set</h4><p>因为区间不相交，所以以 <script type="math/tex">x</script> 为第一关键字排序后是单调递增的。<br>很明显就是找包含这个区间前驱与后继。</p><p> <script type="math/tex">std::set</script> 就行，注意细节处理，主要是 <script type="math/tex">set.end()</script> 很麻烦。<br>不得不说 <script type="math/tex">std::pair</script> 实在是很方便。<br>还有注意相同区间。<br>时间复杂度： <script type="math/tex">O(nlogn)</script> 。</p><h4 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h4><p>也是找包含这个区间前驱与后继。<br>不过要手打，这里因为懒就只打了 <script type="math/tex">std::set</script> 。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">1e6</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">99999997</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii std::pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp std::make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;pii&gt; tim;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;pii&gt;::iterator it1, it2;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;pii&gt; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">char</span> cmd = <span class="number">0</span>;</span><br><span class="line">  REG <span class="keyword">int</span> ax, ay, bx, by, ans;</span><br><span class="line">  FOR(i,<span class="number">0</span>,n)  &#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isalpha</span>(cmd = getchar()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cmd == <span class="string">'A'</span>)  &#123;</span><br><span class="line">      ans = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ax &gt;&gt; ay;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(tim.count(mp(ax, ay)))   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      tim.insert(mp(ax, ay));</span><br><span class="line">      it1 = tim.find(mp(ax, ay));</span><br><span class="line"></span><br><span class="line">      it2 = it1;</span><br><span class="line">      <span class="keyword">if</span>(it1 != tim.begin())  &#123;</span><br><span class="line">        --it2;</span><br><span class="line">        <span class="keyword">for</span>( ; ; --it2) &#123;</span><br><span class="line">          <span class="keyword">if</span>((*it2).y &gt;= ax)  <span class="built_in">stack</span>.push(mp((*it2).x, (*it2).y));</span><br><span class="line">          <span class="keyword">else</span>    <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span>(it2 == tim.begin())  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      it2 = it1;</span><br><span class="line">      <span class="keyword">if</span>(++it1 != tim.end())  &#123;</span><br><span class="line">        ++it2;</span><br><span class="line">        <span class="keyword">for</span>( ; ; ++it2) &#123;</span><br><span class="line">          <span class="keyword">if</span>(it2 == tim.end())  <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span>((*it2).x &lt;= ay)  <span class="built_in">stack</span>.push(mp((*it2).x, (*it2).y));</span><br><span class="line">          <span class="keyword">else</span>    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())   &#123;</span><br><span class="line">        ++ans, tim.erase(tim.find(<span class="built_in">stack</span>.top()));</span><br><span class="line">        <span class="built_in">stack</span>.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tim.size());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>这里用了 <script type="math/tex">std::pair</script> 和  <script type="math/tex">std::set</script> 实现， <script type="math/tex">std::pair</script> 和 <script type="math/tex">std::set</script> 大法好！</li></ul>]]></content>
      
      <categories>
          
          <category> 各省省选 </category>
          
          <category> SHOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> std::set </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[NOIp2013] 火柴排队</title>
      <link href="//NOIp2013-%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F/"/>
      <url>//NOIp2013-%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/1966" target="_blank" rel="noopener">[NOIp2013]火柴排队</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>有两列共 <script type="math/tex">n \ (n <= 100000)</script> 支火柴</p><p>两列火柴之间的距离定义为：</p><script type="math/tex; mode=display">\sum (a_{i} - b_{i})^2</script><p>通过交换使得两列火柴之间的距离最小，出这个最小交换次数对 <script type="math/tex">99,999,997</script> 取模。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h4><p>易发现将两列火柴排序后距离最小。<br>不做证明。<br>很明显的归并排序。<br>排序后记录对应关系，跑一遍树状数组即可。<br>时间复杂度： <script type="math/tex">O(nlogn)</script> 。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">1e5</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">99999997</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii std::pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp std::make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> c[kmax_num];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(REG <span class="keyword">int</span> pos, REG <span class="keyword">int</span> num)</span>  </span>&#123; <span class="keyword">for</span>( ; pos &lt;= n; pos += pos &amp; -pos)  c[pos] += num; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(REG <span class="keyword">int</span> pos)</span>  </span>&#123; REG <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="keyword">for</span>( ; pos; pos -= pos &amp; -pos)  ans += c[pos]; <span class="keyword">return</span> ans; &#125;</span><br><span class="line"></span><br><span class="line">pii num1[kmax_num], num2[kmax_num];</span><br><span class="line"><span class="keyword">int</span> hash1[kmax_num], hash2[kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mod</span><span class="params">(REG <span class="keyword">long</span> <span class="keyword">long</span>&amp; num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(num &lt; <span class="number">0</span>)  num += kmod;</span><br><span class="line">  <span class="keyword">while</span>(num &gt;= kmod)  num -= kmod;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  For(i,<span class="number">1</span>,n)  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; num1[i].first, num1[i].second = i;</span><br><span class="line">  For(i,<span class="number">1</span>,n)  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; num2[i].first, num2[i].second = i;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::sort(num1 + <span class="number">1</span>, num1 + n + <span class="number">1</span>),</span><br><span class="line">  <span class="built_in">std</span>::sort(num2 + <span class="number">1</span>, num2 + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  For(i,<span class="number">1</span>,n)  hash1[num1[i].second] = num2[i].second;</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">  For(i,<span class="number">1</span>,n)  &#123;</span><br><span class="line">    Add(hash1[i], <span class="number">1</span>);</span><br><span class="line">    ans += i - Sum(hash1[i]);</span><br><span class="line">    Mod(ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>这里记录相对位置用了 <script type="math/tex">std::pair</script> 实现，还是 <script type="math/tex">std::pair</script> 大法好！</li></ul>]]></content>
      
      <categories>
          
          <category> NOIp </category>
          
          <category> 2013 </category>
          
          <category> PJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆序对 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HNOI2004] 打鼹鼠</title>
      <link href="//HNOI2004-%E6%89%93%E9%BC%B9%E9%BC%A0/"/>
      <url>//HNOI2004-%E6%89%93%E9%BC%B9%E9%BC%A0/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/2285" target="_blank" rel="noopener">[HNOI2004]打鼹鼠</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>在一个 <script type="math/tex">n * n \ (n <= 1000)</script> 的网格中。你可以控制一个机器人来打 <script type="math/tex">m \ (m <= 10000)</script> 只鼹鼠，如果 <script type="math/tex">i</script> 时刻鼹鼠和机器人处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能向相邻的网格移动一格或停留在原地不动。</p><p>机器人不能走出整个 <script type="math/tex">n * n</script> 的网格。可以自由选定机器人的初始位置。</p><p>求在这一段时间内打死尽可能多的鼹鼠的数目。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><p>可以发现机器人能移动的坐标差只与时间有关。<br>设 <script type="math/tex">f[i]</script> 为 <script type="math/tex">i</script> 时刻能打死几只鼹鼠。<br>状态转移方程：<br> `$$ \begin {equation<em>}<br>f[i] = \sum _ {j &lt; i}^{j  = 0}std::max(f[i] \ , \ f[j] + 1)(and \ t[i] - t[j] &gt; abs(x[i] - x[j]) + abs(y[i] - y[j]))<br> \end {equation</em>}</p><p> <script type="math/tex">`时间复杂度：</script>(n^{2})$$ 。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">1e4</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii std::pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pipii std::pair<span class="meta-string">&lt;int, pii&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp std::make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">pipii t[kmax_num];</span><br><span class="line"><span class="keyword">int</span> f[kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  REG <span class="keyword">int</span> tim, x, y;</span><br><span class="line">  FOR(i,<span class="number">0</span>,m)  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt;tim &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      t[i] = mp(tim, mp(x, y));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  FOR(i,<span class="number">0</span>,m)  &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    FOR(h,<span class="number">0</span>,i) &#123;</span><br><span class="line">      <span class="keyword">if</span>(t[i].first - t[h].first &gt;= <span class="built_in">abs</span>(t[i].second.first - t[h].second.first) +</span><br><span class="line">                                    <span class="built_in">abs</span>(t[i].second.second - t[h].second.second))</span><br><span class="line">        f[i] = <span class="built_in">std</span>::max(f[i], f[h] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">std</span>::max(ans, f[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>这里还是用了 $std::pair$ ，$std::pair$ 大法好！（虽然没什么用</li></ul>]]></content>
      
      <categories>
          
          <category> 各省省选 </category>
          
          <category> HNOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[AHOI2012] 信号塔</title>
      <link href="//AHOI2012-%E4%BF%A1%E5%8F%B7%E5%A1%94/"/>
      <url>//AHOI2012-%E4%BF%A1%E5%8F%B7%E5%A1%94/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/2533" target="_blank" rel="noopener">[AHOI2012]信号塔</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>求 <script type="math/tex">n \ (n <= 1000000)</script> 个点的最小圆覆盖。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始还傻傻的以为是平面最远点对。<br>一个等边三角形就可以 $hack$ 掉。</p><h4 id="随机增量法"><a href="#随机增量法" class="headerlink" title="随机增量法"></a>随机增量法</h4><p>随机化！<br>随机加点，判断是否在圆内。<br>若不在。<br>若构成圆的点只有 $1$ 个点，则以它为圆心。<br>若构成圆的点有 $2$ 个点，则以它们的中点为圆心。<br>若构成圆的点有 $3$ 个点，则以它们的外心为圆心。<br>求外心别看别人的毒瘤公式，自己推一推就出来了。<br>也就是求两个一次函数的交点。<br>理论时间复杂度： $(n^{3})$ 。<br>期望时间复杂度： $(n)$ 。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="随机增量法-1"><a href="#随机增量法-1" class="headerlink" title="随机增量法"></a>随机增量法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">1e6</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd std::pair<span class="meta-string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp std::make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x)  ((x) * (x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pdd point[kmax_num];</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Dist</span><span class="params">(REG <span class="keyword">int</span> a, REG <span class="keyword">int</span> b)</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">double</span>) <span class="built_in">sqrt</span>(sqr(point[a].x - point[b].x) +</span><br><span class="line">                       sqr(point[a].y - point[b].y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">In</span><span class="params">(REG <span class="keyword">int</span> a)</span>   </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Dist(n, a) - r &lt; eps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Get</span><span class="params">(REG <span class="keyword">int</span> a, REG <span class="keyword">int</span> b, REG <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  REG <span class="keyword">double</span>  k1 = <span class="number">-1</span> / ((point[a].y - point[b].y) / (point[a].x - point[b].x)),</span><br><span class="line">              k2 = <span class="number">-1</span> / ((point[b].y - point[c].y) / (point[b].x - point[c].x));</span><br><span class="line">  REG <span class="keyword">double</span>  b1 = (point[a].y + point[b].y) / <span class="number">2</span> - k1 * (point[a].x + point[b].x) / <span class="number">2</span>,</span><br><span class="line">              b2 = (point[b].y + point[c].y) / <span class="number">2</span> - k2 * (point[b].x + point[c].x) / <span class="number">2</span>;</span><br><span class="line">  REG <span class="keyword">double</span>  bx = - (b1 - b2) / (k1 - k2);</span><br><span class="line">  point[n] = mp(bx, k1 * bx + b1);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">" %d"</span>, &amp;n);</span><br><span class="line">  REG <span class="keyword">double</span> ax, ay;</span><br><span class="line">  FOR(i,<span class="number">0</span>,n)  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">" %lf %lf"</span>, &amp;ax, &amp;ay);</span><br><span class="line">    point[i] = mp(ax, ay);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::random_shuffle(point, point + n);</span><br><span class="line"></span><br><span class="line">  point[n] = point[<span class="number">0</span>];</span><br><span class="line">  FOR(i,<span class="number">0</span>,n)  <span class="keyword">if</span>(!In(i))&#123;</span><br><span class="line">    point[n] = point[i];</span><br><span class="line">    r = <span class="number">0.000</span>;</span><br><span class="line"></span><br><span class="line">    FOR(h,<span class="number">0</span>,i) <span class="keyword">if</span>(!In(h))&#123;</span><br><span class="line">      point[n].x = (point[i].x + point[h].x) / <span class="number">2</span>;</span><br><span class="line">      point[n].y = (point[i].y + point[h].y) / <span class="number">2</span>;</span><br><span class="line">      r = Dist(n, i);</span><br><span class="line"></span><br><span class="line">      FOR(k,<span class="number">0</span>,h) <span class="keyword">if</span>(!In(k))&#123;</span><br><span class="line">        Get(i, h, k);</span><br><span class="line">        r = Dist(n, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%.2lf %.2lf %.2lf\n"</span>, point[n].x, point[n].y, r);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>推外心公式时还忘了变号，调了调了一晚上。</li><li>这里还是用了 <script type="math/tex">std::pair</script> ，<script type="math/tex">std::pair</script> 大法好！</li></ul>]]></content>
      
      <categories>
          
          <category> 各省省选 </category>
          
          <category> AHOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 最小圆覆盖 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HNOI2010] 弹飞绵羊</title>
      <link href="//HNOI2010-%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A/"/>
      <url>//HNOI2010-%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/3203" target="_blank" rel="noopener">[HNOI2010]弹飞绵羊</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>地上沿着一条直线摆着 <script type="math/tex">n \ (n <= 200000)</script> 个装置，每个装置设定初始弹力系数 <script type="math/tex">k_{i}</script> ，当绵羊达到第 <script type="math/tex">i</script> 个装置时，它会往后弹 <script type="math/tex">k_{i}</script>步，达到第 <script type="math/tex">i + k_{i}</script> 个装置，若不存在第 <script type="math/tex">i + k_{i}</script> 个装置，则绵羊被弹飞。</p><p>要支持 <script type="math/tex">m (m \ <= 100000)</script> 次 <script type="math/tex">2</script> 种操作。</p><ul><li>查询从 <script type="math/tex">x</script> 出发后几次被弹飞。</li><li>将 <script type="math/tex">x</script> 处的弹力系数改为 <script type="math/tex">y</script> 。</li></ul><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="优雅的暴力"><a href="#优雅的暴力" class="headerlink" title="优雅的暴力"></a>优雅的暴力</h4><p>可谓：</p><blockquote><p>n方过十万，暴力碾标算。</p></blockquote><p>要修改先不改，累计到了 <script type="math/tex">lim</script> 再一起重新统计。<br>暴力查询。<br>就这样。（说到底还是暴力<br>时间复杂度： $(n?)$ 。<br>随机数据能保证复杂度。<br>但要是碰到毒瘤出题人就会被卡掉。</p><h4 id="LCT"><a href="#LCT" class="headerlink" title="LCT"></a>LCT</h4><p>我太蒻了，学了再补全。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">2e5</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, lim = <span class="number">100</span>, last;</span><br><span class="line"><span class="keyword">int</span> f[kmax_num], c[kmax_num], t[kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(REG <span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(c[i])    f[i] = c[i], c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i + f[i] &gt;= n)       t[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>                    t[i] = t[i + f[i]] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(REG <span class="keyword">int</span> pos)</span>   </span>&#123;</span><br><span class="line">  REG <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(pos &lt;= last)  &#123;</span><br><span class="line">    pos += (c[pos] ? c[pos] : f[pos]);</span><br><span class="line">    ++ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t[pos] + ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  FOR(i,<span class="number">0</span>,n)  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; f[i];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">  REG <span class="keyword">int</span> cmd, x, y;</span><br><span class="line">  FOR(i,<span class="number">0</span>,m)  &#123;</span><br><span class="line">    <span class="keyword">if</span>(lim == <span class="number">100</span>)  lim = <span class="number">0</span>, last = <span class="number">-1</span>, Flush();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cmd;</span><br><span class="line">    <span class="keyword">if</span>(cmd == <span class="number">1</span>)    &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Query(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      <span class="keyword">if</span>((f[x] == y &amp;&amp; c[x] == <span class="number">0</span>) || c[x] == y)  <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(f[x] == y &amp;&amp; c[x] != <span class="number">0</span>)  c[x] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(f[x] != y)   &#123;</span><br><span class="line">        c[x] = y, ++lim;</span><br><span class="line">        last = <span class="built_in">std</span>::max(last, x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>暴力中的 <script type="math/tex">lim</script> 你们可以尝试改一下。</li></ul>]]></content>
      
      <categories>
          
          <category> 各省省选 </category>
          
          <category> HNOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[SDOI2008] 洞穴勘测</title>
      <link href="//SDOI2008-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B/"/>
      <url>//SDOI2008-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/2147" target="_blank" rel="noopener">[SDOI2008]洞穴勘测</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>使 <script type="math/tex">n \ (n <= 10000)</script> 个节点的一棵树支持 <script type="math/tex">m \ (m <= 200000)</script> 3种操作：</p><ul><li>连接 <script type="math/tex">(u, v)</script> 。</li><li>断开 <script type="math/tex">(u, v)</script> 。</li><li>查询 <script type="math/tex">(u, v)</script> 是否联通。</li></ul><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力并查集"><a href="#暴力并查集" class="headerlink" title="暴力并查集"></a>暴力并查集</h4><p>这很明显就是维护动态森林吧。<br>每次操作前先将<code>$x$</code> 提根。<br>连接时将 <script type="math/tex">y</script> 设为 <script type="math/tex">x</script> 的父亲。<br>断开时将 <script type="math/tex">y</script> 的父亲设为 <script type="math/tex">0</script> 。<br>暴力查询。<br>玄学复杂度。<br>时间复杂度： <script type="math/tex">O(?)</script> 。<br>不过据说是随机数据所以跑得比香港记者还快。</p><h4 id="LCT"><a href="#LCT" class="headerlink" title="LCT"></a>LCT</h4><p>我太蒻了，学了再补全。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="暴力并查集-1"><a href="#暴力并查集-1" class="headerlink" title="暴力并查集"></a>暴力并查集</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">1e4</span>+ <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPlay</span><span class="params">(REG <span class="keyword">int</span> x)</span>    </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(REG <span class="keyword">int</span> a = <span class="number">0</span>, fa = f[x]; x; fa = f[x])</span><br><span class="line">    f[x] = a, a = x, x = fa;</span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">char</span> cmd;</span><br><span class="line">  REG <span class="keyword">int</span> u, v;</span><br><span class="line">  FOR(i,<span class="number">0</span>,m)  &#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isalpha</span>(cmd = getchar()))    <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    SPlay(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cmd == <span class="string">'C'</span>)          f[u] = v;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">if</span>(cmd == <span class="string">'D'</span>)  f[v] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>    &#123;</span><br><span class="line">      <span class="keyword">for</span>( ; u != v &amp;&amp; v; v = f[v])   <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">puts</span>(u == v ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>并查集提根就相当于翻转区间 <script type="math/tex">(Splay)</script> 。</li></ul>]]></content>
      
      <categories>
          
          <category> 各省省选 </category>
          
          <category> SDOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[SCOI2008] 配对</title>
      <link href="//SCOI2008-%E9%85%8D%E5%AF%B9/"/>
      <url>//SCOI2008-%E9%85%8D%E5%AF%B9/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/2507" target="_blank" rel="noopener">[SCOI2008]配对</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>有一个 <script type="math/tex">n \ (n <= 100000)</script> 对整数需要配对。</p><p>所有配对的整数差的绝对值之和尽量小，但不允许两个相同的数配对。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力DP？"><a href="#暴力DP？" class="headerlink" title="暴力DP？"></a>暴力DP？</h4><p>一开始我是一头雾水，看了 <script type="math/tex">dalao</script> 博客才知道要分类讨论。<br>由于我 <script type="math/tex">markdown</script> 技术巨烂，将就看看吧。</p><h5 id="与距离为0的数匹配"><a href="#与距离为0的数匹配" class="headerlink" title="与距离为0的数匹配"></a>与距离为0的数匹配</h5><ul><li><script type="math/tex; mode=display">a_{1} \\ | \\ b_{1}</script></li></ul><h5 id="与距离为1的数匹配"><a href="#与距离为1的数匹配" class="headerlink" title="与距离为1的数匹配"></a>与距离为1的数匹配</h5><ul><li><script type="math/tex; mode=display">\ \ \ \ \ a_{1} \quad a_{2} \\ \quad \backslash \\ \ \ \ \ \ b_{1} \quad b_{2} \\ +   a_{2} ~\rightarrow b_{2}</script></li></ul><h5 id="与距离为2的数匹配"><a href="#与距离为2的数匹配" class="headerlink" title="与距离为2的数匹配"></a>与距离为2的数匹配</h5><ul><li><script type="math/tex; mode=display">a_{1} \quad a_{2} \quad a_{3} \\ \backslash \quad \ \backslash \\ b_{1} \quad b_{2} \quad b_{3} \\ +   a_{3} ~\rightarrow b_{1} \\</script></li><li><script type="math/tex; mode=display">a_{1} \quad a_{2} \quad a_{3} \\ / \quad \ / \\ b_{1} \quad b_{2} \quad b_{3} \\ + a_{1} ~\rightarrow b_{3} \\</script></li><li><script type="math/tex; mode=display">a_{1} \quad a_{2} \quad a_{3} \\ | \\ b_{1} \quad b_{2} \quad b_{3} \\ + a_{1} ~\rightarrow b_{3} \\ + a_{3} ~\rightarrow b_{1} \\</script></li></ul><h5 id="与距离为3的数匹配"><a href="#与距离为3的数匹配" class="headerlink" title="与距离为3的数匹配"></a>与距离为3的数匹配</h5><p>可以发现最优情况一定是两个与距离为1的数匹配。</p><ul><li><script type="math/tex; mode=display">a_{1} \quad a_{2} \quad a_{3} \quad a_{4} \\ \backslash \quad \ \ \ \ \ \ \ \ \ \ \backslash \\ b_{1} \quad b_{2} \quad b_{3} \quad b_{4} \\ +   a_{2} ~\rightarrow b_{1} \\ +   a_{4} ~\rightarrow b_{3} \\</script></li></ul><h5 id="分类讨论"><a href="#分类讨论" class="headerlink" title="分类讨论"></a>分类讨论</h5><p>所以只有 <script type="math/tex">5</script> 种情况，慢慢递推处理就好。<br>时间复杂度： <script type="math/tex">O(n)</script> 。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">1e5</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> n1[kmax_num], n2[kmax_num];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  For(i,<span class="number">1</span>,n)  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n1[i] &gt;&gt; n2[i];</span><br><span class="line">  <span class="built_in">std</span>::sort(n1 + <span class="number">1</span>, n1 + n + <span class="number">1</span>), <span class="built_in">std</span>::sort(n2 + <span class="number">1</span>, n2 + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  For(i,<span class="number">1</span>,n)  &#123;</span><br><span class="line">    f[i] = f[i - <span class="number">1</span>] + (n1[i] == n2[i] ? <span class="number">0x3f3f3f3f</span> : <span class="built_in">abs</span>(n1[i] - n2[i]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">2</span> &amp;&amp; n1[i - <span class="number">1</span>] != n2[i] &amp;&amp; n1[i] != n2[i - <span class="number">1</span>])</span><br><span class="line">      f[i] = <span class="built_in">std</span>::min(f[i], f[i - <span class="number">2</span>] + <span class="built_in">abs</span>(n1[i - <span class="number">1</span>] - n2[i]) + <span class="built_in">abs</span>(n1[i] - n2[i - <span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">3</span> &amp;&amp; n1[i - <span class="number">2</span>] != n2[i - <span class="number">1</span>] &amp;&amp; n1[i - <span class="number">1</span>] != n2[i] &amp;&amp; n1[i] != n2[i - <span class="number">2</span>])</span><br><span class="line">      f[i] = <span class="built_in">std</span>::min(f[i], f[i - <span class="number">3</span>] + <span class="built_in">abs</span>(n1[i - <span class="number">2</span>] - n2[i - <span class="number">1</span>]) + <span class="built_in">abs</span>(n1[i - <span class="number">1</span>] - n2[i]) + <span class="built_in">abs</span>(n1[i] - n2[i - <span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">3</span> &amp;&amp; n1[i - <span class="number">2</span>] != n2[i] &amp;&amp; n1[i - <span class="number">1</span>] != n2[i - <span class="number">2</span>] &amp;&amp; n1[i] != n2[i - <span class="number">1</span>])</span><br><span class="line">      f[i] = <span class="built_in">std</span>::min(f[i], f[i - <span class="number">3</span>] + <span class="built_in">abs</span>(n1[i - <span class="number">2</span>] - n2[i]) + <span class="built_in">abs</span>(n1[i - <span class="number">1</span>] - n2[i - <span class="number">2</span>]) + <span class="built_in">abs</span>(n1[i] - n2[i - <span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">3</span> &amp;&amp; n1[i - <span class="number">2</span>] != n2[i] &amp;&amp; n1[i - <span class="number">1</span>] != n2[i - <span class="number">1</span>] &amp;&amp; n1[i] != n2[i - <span class="number">2</span>])</span><br><span class="line">      f[i] = <span class="built_in">std</span>::min(f[i], f[i - <span class="number">3</span>] + <span class="built_in">abs</span>(n1[i - <span class="number">2</span>] - n2[i]) + <span class="built_in">abs</span>(n1[i - <span class="number">1</span>] - n2[i - <span class="number">1</span>]) + <span class="built_in">abs</span>(n1[i] - n2[i - <span class="number">2</span>]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>记得要开 <script type="math/tex">long long</script> 。</li><li>这份代码十分暴力。</li></ul>]]></content>
      
      <categories>
          
          <category> 各省省选 </category>
          
          <category> SCOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HAOI2009] 逆序对数列</title>
      <link href="//HAOI2009-%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E5%88%97/"/>
      <url>//HAOI2009-%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E5%88%97/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/2513" target="_blank" rel="noopener">[HAOI2009]逆序对数列</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>求 <script type="math/tex">n \ (n <= 1000)</script> 的全排列中逆序对个数为 <script type="math/tex">k \ (k <= 1000)</script> 的数目。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>暴力枚举全排列 <script type="math/tex">(std::next \_ permutation)</script> ，暴力统计。<br>时间复杂度： <script type="math/tex">O(!n * n^{2})</script> 。<br>预期得分： <script type="math/tex">(30)</script> 。</p><h4 id="暴力-UDP"><a href="#暴力-UDP" class="headerlink" title="暴力-UDP"></a>暴力-UDP</h4><p>暴力枚举全排列 <script type="math/tex">(std::next \_ permutation)</script> ，树状数组求逆序对。<br>时间复杂度： <script type="math/tex">O(!n * nlogn)</script> 。<br>预期得分： <script type="math/tex">(30)</script> 。</p><h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><p>新来的数是坠大的，所以把它插入到第 <script type="math/tex">pos</script> 个位置会产生 <script type="math/tex">(n - pos - 1)</script> 个逆序对。<br>状态转移方程：<br> `$$ \begin {equation<em>}<br>f[n][k] = \sum _ {h=std::max(0, k - n + 1)}^kf[n - 1][h]<br> \end {equation</em>}</p><p> <script type="math/tex">`时间复杂度：</script>O(n^{3})<script type="math/tex">。预期得分：</script>(60)$$ 。</p><h4 id="DP-UDP"><a href="#DP-UDP" class="headerlink" title="DP-UDP"></a>DP-UDP</h4><p>可以发现每次转移都是一段区间，考虑用前缀和维护。<br>时间复杂度： <script type="math/tex">O(n^{2})</script>  。<br>预期得分： <script type="math/tex">(100)</script> 。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">1e3</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[kmax_num][kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mod</span><span class="params">(REG <span class="keyword">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(num &lt; <span class="number">0</span>)  num += kmod;</span><br><span class="line">  <span class="keyword">while</span>(num &gt;= kmod)  num -= kmod;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  f[<span class="number">2</span>][<span class="number">0</span>] = f[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  s[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>, s[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">2</span>, s[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">2</span>, s[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">int</span> sum;</span><br><span class="line">  For(i,<span class="number">3</span>,n)  &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    For(h,<span class="number">0</span>,m)  &#123;</span><br><span class="line">      sum += f[i - <span class="number">1</span>][h];</span><br><span class="line">      <span class="keyword">if</span>(h - i &gt;= <span class="number">0</span>)  sum -= f[i - <span class="number">1</span>][h - i];</span><br><span class="line">      Mod(sum);</span><br><span class="line">      f[i][h] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n][m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>一开始没用前缀和 <script type="math/tex">TLE</script> 还 <script type="math/tex">debug</script> 了好久。</li><li>原来的前缀和计算是用数组乱搞的，后来重构了。</li></ul>]]></content>
      
      <categories>
          
          <category> 各省省选 </category>
          
          <category> HAOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HAOI2007] 理想的正方形</title>
      <link href="//HAOI2007-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
      <url>//HAOI2007-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/2216" target="_blank" rel="noopener">[HAOI2007]理想的正方形</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>有一个 <script type="math/tex">n * m \ (n, \ m <= 1000)</script> 的整数组成的矩阵。</p><p>找出一个 <script type="math/tex">k * k \ (k <= 100)</script> 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>首先考虑暴力，也就是暴力枚举起点，暴力求最大值和最小值。<br>时间复杂度： $O(n^{4})$ 。</p><h4 id="二维RMQ"><a href="#二维RMQ" class="headerlink" title="二维RMQ"></a>二维RMQ</h4><p>看到要求最大值与最小值，就想起RMQ。<br>常规二维RMQ空间复杂度太大，需要 $(n^{2}2logk)$ 的空间， 开不下啊2333。<br>但是这道题很特殊，它的查询的是正方形，因此并不需要二维倍增。<br>所以就砍下了一维。<br>下面会给出常规二维RMQ与特殊二维RMQ。<br>空间复杂度： $O(n^{2}logk)$ 。<br>时间复杂度： $O(n^{2}logk)$ 。</p><h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><p>据说可以用单调队列维护。<br>我太蒻了，并不会。。。。。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="二维RMQ-1"><a href="#二维RMQ-1" class="headerlink" title="二维RMQ"></a>二维RMQ</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">1e3</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> rmq_max[kmax_num][kmax_num][<span class="number">11</span>][<span class="number">11</span>], rmq_min[kmax_num][kmax_num][<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(REG <span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span>(REG <span class="keyword">int</span> h = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; h) &lt;= m; ++h)  &#123;</span><br><span class="line">      <span class="keyword">if</span>(!i &amp;&amp; !h)  <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">else</span>  &#123;</span><br><span class="line">        <span class="keyword">for</span>(REG <span class="keyword">int</span> row = <span class="number">1</span>; row + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; ++row)</span><br><span class="line">          <span class="keyword">for</span>(REG <span class="keyword">int</span> col = <span class="number">1</span>; col + (<span class="number">1</span> &lt;&lt; h) - <span class="number">1</span> &lt;= m; ++col)</span><br><span class="line">            <span class="keyword">if</span>(i) rmq_max[row][col][i][h] = <span class="built_in">std</span>::max(rmq_max[row][col][i - <span class="number">1</span>][h], rmq_max[row + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][col][i - <span class="number">1</span>][h]),</span><br><span class="line">                  rmq_min[row][col][i][h] = <span class="built_in">std</span>::min(rmq_min[row][col][i - <span class="number">1</span>][h], rmq_min[row + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][col][i - <span class="number">1</span>][h]);</span><br><span class="line">            <span class="keyword">else</span>  rmq_max[row][col][i][h] = <span class="built_in">std</span>::max(rmq_max[row][col][i][h - <span class="number">1</span>], rmq_max[row][col + (<span class="number">1</span> &lt;&lt; (h - <span class="number">1</span>))][i][h - <span class="number">1</span>]),</span><br><span class="line">                  rmq_min[row][col][i][h] = <span class="built_in">std</span>::min(rmq_min[row][col][i][h - <span class="number">1</span>], rmq_min[row][col + (<span class="number">1</span> &lt;&lt; (h - <span class="number">1</span>))][i][h - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(REG <span class="keyword">int</span> ax, REG <span class="keyword">int</span> ay, REG <span class="keyword">int</span> bx, REG <span class="keyword">int</span> by)</span>  </span>&#123;</span><br><span class="line">  REG <span class="keyword">int</span> t1 = (<span class="keyword">int</span>) log2(bx - ax + <span class="number">1</span>);</span><br><span class="line">  REG <span class="keyword">int</span> t2 = (<span class="keyword">int</span>) log2(by - ay + <span class="number">1</span>);</span><br><span class="line">  REG <span class="keyword">int</span> m1 = rmq_max[ax][ay][t1][t2];</span><br><span class="line">  REG <span class="keyword">int</span> m2 = rmq_max[bx - (<span class="number">1</span> &lt;&lt; t1) + <span class="number">1</span>][ay][t1][t2];</span><br><span class="line">  REG <span class="keyword">int</span> m3 = rmq_max[ax][by - (<span class="number">1</span> &lt;&lt; t2) + <span class="number">1</span>][t1][t2];</span><br><span class="line">  REG <span class="keyword">int</span> m4 = rmq_max[bx - (<span class="number">1</span> &lt;&lt; t1) + <span class="number">1</span>][by - (<span class="number">1</span> &lt;&lt; t2) + <span class="number">1</span>][t1][t2];</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">int</span> m5 = rmq_min[ax][ay][t1][t2];</span><br><span class="line">  REG <span class="keyword">int</span> m6 = rmq_min[bx - (<span class="number">1</span> &lt;&lt; t1) + <span class="number">1</span>][ay][t1][t2];</span><br><span class="line">  REG <span class="keyword">int</span> m7 = rmq_min[ax][by - (<span class="number">1</span> &lt;&lt; t2) + <span class="number">1</span>][t1][t2];</span><br><span class="line">  REG <span class="keyword">int</span> m8 = rmq_min[bx - (<span class="number">1</span> &lt;&lt; t1) + <span class="number">1</span>][by - (<span class="number">1</span> &lt;&lt; t2) + <span class="number">1</span>][t1][t2];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::max(<span class="built_in">std</span>::max(m1, m2), <span class="built_in">std</span>::max(m3, m4)) - <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(m5, m6), <span class="built_in">std</span>::min(m7, m8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维RMQ-UDP"><a href="#二维RMQ-UDP" class="headerlink" title="二维RMQ-UDP"></a>二维RMQ-UDP</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">1e3</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> rmq_max[kmax_num][kmax_num][<span class="number">11</span>], rmq_min[kmax_num][kmax_num][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(REG <span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= k; ++i)  &#123;</span><br><span class="line">    <span class="keyword">for</span>(REG <span class="keyword">int</span> row = <span class="number">1</span>; row + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; ++row)</span><br><span class="line">    <span class="keyword">for</span>(REG <span class="keyword">int</span> col = <span class="number">1</span>; col + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= m; ++col)</span><br><span class="line">    rmq_max[row][col][i] = <span class="built_in">std</span>::max(<span class="built_in">std</span>::max(rmq_max[row][col][i - <span class="number">1</span>], rmq_max[row + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][col][i - <span class="number">1</span>]),</span><br><span class="line">                           <span class="built_in">std</span>::max(rmq_max[row][col + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>], rmq_max[row + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][col + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>])),</span><br><span class="line">    rmq_min[row][col][i] = <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(rmq_min[row][col][i - <span class="number">1</span>], rmq_min[row + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][col][i - <span class="number">1</span>]),</span><br><span class="line">                           <span class="built_in">std</span>::min(rmq_min[row][col + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>], rmq_min[row + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][col + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(REG <span class="keyword">int</span> ax, REG <span class="keyword">int</span> ay, REG <span class="keyword">int</span> bx, REG <span class="keyword">int</span> by)</span>  </span>&#123;</span><br><span class="line">    REG <span class="keyword">int</span> t1 = (<span class="keyword">int</span>) log2(bx - ax + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//  REG int t1 = (int) log2(k + 1);</span></span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">int</span> m1 = rmq_max[ax][ay][t1];</span><br><span class="line">  REG <span class="keyword">int</span> m2 = rmq_max[bx - (<span class="number">1</span> &lt;&lt; t1) + <span class="number">1</span>][ay][t1];</span><br><span class="line">  REG <span class="keyword">int</span> m3 = rmq_max[ax][by - (<span class="number">1</span> &lt;&lt; t1) + <span class="number">1</span>][t1];</span><br><span class="line">  REG <span class="keyword">int</span> m4 = rmq_max[bx - (<span class="number">1</span> &lt;&lt; t1) + <span class="number">1</span>][by - (<span class="number">1</span> &lt;&lt; t1) + <span class="number">1</span>][t1];</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">int</span> m5 = rmq_min[ax][ay][t1];</span><br><span class="line">  REG <span class="keyword">int</span> m6 = rmq_min[bx - (<span class="number">1</span> &lt;&lt; t1) + <span class="number">1</span>][ay][t1];</span><br><span class="line">  REG <span class="keyword">int</span> m7 = rmq_min[ax][by - (<span class="number">1</span> &lt;&lt; t1) + <span class="number">1</span>][t1];</span><br><span class="line">  REG <span class="keyword">int</span> m8 = rmq_min[bx - (<span class="number">1</span> &lt;&lt; t1) + <span class="number">1</span>][by - (<span class="number">1</span> &lt;&lt; t1) + <span class="number">1</span>][t1];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::max(<span class="built_in">std</span>::max(m1, m2), <span class="built_in">std</span>::max(m3, m4)) - <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(m5, m6), <span class="built_in">std</span>::min(m7, m8));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  For(i,<span class="number">1</span>,n)  For(h,<span class="number">1</span>,m)  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; rmq_max[i][h][<span class="number">0</span>], rmq_min[i][h][<span class="number">0</span>] = rmq_max[i][h][<span class="number">0</span>];</span><br><span class="line">  Init();</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">int</span> ans = <span class="number">0x7fffffff</span>;</span><br><span class="line">  <span class="keyword">for</span>(REG <span class="keyword">int</span> i = <span class="number">1</span>; i + k - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">  <span class="keyword">for</span>(REG <span class="keyword">int</span> h = <span class="number">1</span>; h + k - <span class="number">1</span> &lt;= m; ++h)</span><br><span class="line">    ans = <span class="built_in">std</span>::min(ans, Query(i, h, i + k - <span class="number">1</span>, h + k - <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>这里的二维 <script type="math/tex">RMQ</script> 要是 <script type="math/tex">(n \ == \ 0 \ || \ m \ == \ 0)</script> 就是一个一维 <script type="math/tex">RMQ</script> 。</li></ul>]]></content>
      
      <categories>
          
          <category> 各省省选 </category>
          
          <category> HAOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维RMQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[HNOI2003] 消防局的设立</title>
      <link href="//HNOI2003-%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B/"/>
      <url>//HNOI2003-%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/P2279" target="_blank" rel="noopener">[HNOI2003]消防局的设立</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>给出一棵节点数为 <script type="math/tex">n \ (n <= 1000)`$ 的树，每条边长度为 `$1</script> 。</p><p>一次操作作用于一个节点，并将距此节点 <script type="math/tex">dist <= 2</script> 的节点染色，求将整棵树染上颜色的最小次数。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>首先考虑暴力，也就是暴力枚举。<br>时间复杂度： <script type="math/tex">O(n^{2})</script> 。<br>由于数据太水，暴力随便打吧。</p><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>一开始我是想到节点要尽可能向中间靠拢，染色少浪费，可是并不容易做到。<br>从上向下？没思路。（一开始没想到）<br>但从下向上就好想多了。<br>记录 <script type="math/tex">BFS</script> 序，也就是深度。<br>从最底层找起，当它没被染色时，给它的爷爷（雾）染色 <script type="math/tex">(depth <= 2)</script> ，这样能保证高效利用。<br>时间复杂度： <script type="math/tex">O(n)</script> （大概吧）。</p><h4 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h4><p>我太蒻了，并不会。。。。。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">2e3</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii std::pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ppiii std::pair<span class="meta-string">&lt;pii, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp std::make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">pii e[kmax_num];</span><br><span class="line"><span class="keyword">int</span> head[kmax_num], cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(REG <span class="keyword">int</span> u, REG <span class="keyword">int</span> v)</span>  </span>&#123;</span><br><span class="line">  e[++cnt] = mp(v, head[u]);</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">  e[++cnt] = mp(u, head[v]);</span><br><span class="line">  head[v] = cnt;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">  q.push(<span class="number">1</span>), s.push(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty())  &#123;</span><br><span class="line">    REG <span class="keyword">int</span> u = q.front();    q.pop();</span><br><span class="line">    <span class="keyword">for</span>(REG <span class="keyword">int</span> i = head[u]; i; i = e[i].second)</span><br><span class="line">      <span class="keyword">if</span>(e[i].first != f[u])  q.push(e[i].first), s.push(e[i].first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[kmax_num];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;pii&gt; mq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mark</span><span class="params">(REG <span class="keyword">int</span> u, REG <span class="keyword">int</span> dep)</span>  </span>&#123;</span><br><span class="line">  mq.push(mp(u, <span class="number">0</span>));</span><br><span class="line">  <span class="keyword">while</span>(!mq.empty())  &#123;</span><br><span class="line">    REG pii u = mq.front();    mq.pop();</span><br><span class="line">    <span class="keyword">for</span>(REG <span class="keyword">int</span> i = head[u.first]; i; i = e[i].second)  &#123;</span><br><span class="line">      vis[e[i].first] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(u.second &lt; <span class="number">1</span>)  mq.push(mp(e[i].first, u.second + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  FOR(i,<span class="number">1</span>,n)  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; f[i + <span class="number">1</span>], AddEdge(f[i + <span class="number">1</span>], i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  BFS();</span><br><span class="line">  REG <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!s.empty())  &#123;</span><br><span class="line">    REG <span class="keyword">int</span> u = s.top();    s.pop();</span><br><span class="line">    <span class="keyword">if</span>(!vis[u])</span><br><span class="line">      vis[u] = <span class="literal">true</span>, Mark(f[f[u]], <span class="number">0</span>), ++ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>这里用了 <script type="math/tex">std::pair</script> 实现，<script type="math/tex">std::pair</script> 大法好！</li></ul>]]></content>
      
      <categories>
          
          <category> 各省省选 </category>
          
          <category> HNOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CF962D Merge Equals</title>
      <link href="//CF962D-Merge-Equals/"/>
      <url>//CF962D-Merge-Equals/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="http://codeforces.com/contest/962/problem/D" target="_blank" rel="noopener">CF962D Merge Equals</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>给出一个长度为 $n \ (2 &lt;= n &lt;= 150000)$ 的数组， 数组内元素 $a<em>{i} \ (1 &lt;= a</em>{i} &lt;= 1e9)$ 。</p><p>每次操作将数组内两个相同的最小的最靠左的元素取出，并将左边的合并到右边，直到不能操作为止，输出最后的数组。</p><p>例：<br>$[1, 1, 3, 1, 1]~\rightarrow~[2, 3, 1, 1]~\rightarrow~[2, 3, 2]~\rightarrow~[3, 4]$<br><a id="more"></a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>首先考虑暴力，也就是暴力查找。<br>时间复杂度： $O(n^{2})$ 。</p><h4 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h4><p>正解应该挺容易想到的，用堆维护数值和位置，每次取出两个，不相同就删了第一个，否则合并。<br>时间复杂度： $O(n \ log(n))$ 。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">1e6</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pli std::pair<span class="meta-string">&lt;long long, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp std::make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;pli&gt; <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  FOR(i,<span class="number">0</span>,n)  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; f[i], <span class="built_in">set</span>.insert(mp(f[i], i));</span><br><span class="line"></span><br><span class="line">  REG pli t1, t2;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">set</span>.empty()) &#123;</span><br><span class="line">    t1 = *<span class="built_in">set</span>.begin(), t2 = *(++<span class="built_in">set</span>.begin());</span><br><span class="line">    <span class="keyword">if</span>(t1.first != t2.first)  &#123;</span><br><span class="line">      <span class="built_in">set</span>.erase(<span class="built_in">set</span>.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  &#123;</span><br><span class="line">      <span class="built_in">set</span>.insert(mp(t1.first &lt;&lt; <span class="number">1</span>, t2.second));</span><br><span class="line">      f[t1.second] = <span class="number">0</span>;</span><br><span class="line">      f[t2.second] = t1.first &lt;&lt; <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">set</span>.erase(<span class="built_in">set</span>.begin());</span><br><span class="line">      <span class="built_in">set</span>.erase(<span class="built_in">set</span>.begin());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  FOR(i,<span class="number">0</span>,n)  <span class="keyword">if</span>(f[i]) ++ans;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">  FOR(i,<span class="number">0</span>,n)  <span class="keyword">if</span>(f[i]) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, f[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>这里用 <script type="math/tex">std::set</script> 实现，<script type="math/tex">std::set</script> 大法好！</li><li>这里还用了 <script type="math/tex">std::pair</script> 实现，<script type="math/tex">std::pair</script> 大法好！</li><li><a href="https://www.luogu.org/problemnew/show/CF962D" target="_blank" rel="noopener">这道题</a>在洛谷上居然是蓝题！！还不去水一发吗2333</li></ul>]]></content>
      
      <categories>
          
          <category> CodeForces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
            <tag> std::set </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[SCOI2009] 生日礼物</title>
      <link href="//SCOI2009-%E7%94%9F%E6%97%A5%E7%A4%BC%E7%89%A9/"/>
      <url>//SCOI2009-%E7%94%9F%E6%97%A5%E7%A4%BC%E7%89%A9/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/2564" target="_blank" rel="noopener">[SCOI2009]生日礼物</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>有一条纸带上挂着 <script type="math/tex">n \ (n <= 1000000)</script> 个小球，小球有 <script type="math/tex">k \ (k <= 60)</script> 种颜色。</p><p>找出一个最小的包含所有颜色的区间。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p>使一个队列中一直保持有所有颜色，不断向右移动<br>若末尾小球的颜色出现次数 <script type="math/tex">> 1</script> ，将其弹出，直到末尾小球的颜色出现次数 <script type="math/tex">= 1</script> 。<br>时间复杂度：<code>$O(n)$</code> 。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">1e6</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii std::pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp std::make_pair</span></span><br><span class="line"></span><br><span class="line">pii point[kmax_num];</span><br><span class="line"><span class="keyword">int</span> col[<span class="number">61</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;pii&gt;  <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    For(i,<span class="number">1</span>,k)  <span class="keyword">if</span>(!col[i])  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  REG <span class="keyword">int</span> sum, pos, cnt = <span class="number">-1</span>;</span><br><span class="line">  For(i,<span class="number">1</span>,k)  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; sum;</span><br><span class="line">    FOR(h,<span class="number">0</span>,sum)  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; pos;</span><br><span class="line">      point[++cnt] = mp(pos, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::sort(point, point + n);</span><br><span class="line"></span><br><span class="line">  cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(Check())  &#123;</span><br><span class="line">    <span class="built_in">queue</span>.push_front(point[cnt]);</span><br><span class="line">    ++col[point[cnt].second];</span><br><span class="line">    ++cnt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">int</span> ans = <span class="number">0x7fffffff</span>;</span><br><span class="line">  <span class="keyword">while</span>(cnt &lt; n)  &#123;</span><br><span class="line">    ans = <span class="built_in">std</span>::min(ans, <span class="built_in">queue</span>.front().first - <span class="built_in">queue</span>.back().first);</span><br><span class="line">    <span class="built_in">queue</span>.push_front(point[cnt]);</span><br><span class="line">    ++col[point[cnt].second];</span><br><span class="line">    <span class="keyword">while</span>(col[<span class="built_in">queue</span>.back().second] &gt; <span class="number">1</span>)</span><br><span class="line">      --col[<span class="built_in">queue</span>.back().second], <span class="built_in">queue</span>.pop_back();</span><br><span class="line">    ++cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = <span class="built_in">std</span>::min(ans, <span class="built_in">queue</span>.front().first - <span class="built_in">queue</span>.back().first);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>这里用了 <script type="math/tex">std::pair</script> 实现，<script type="math/tex">std::pair</script> 大法好！</li></ul>]]></content>
      
      <categories>
          
          <category> 各省省选 </category>
          
          <category> SCOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[SCOI2011] 糖果</title>
      <link href="//SCOI2011-%E7%B3%96%E6%9E%9C/"/>
      <url>//SCOI2011-%E7%B3%96%E6%9E%9C/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/3275" target="_blank" rel="noopener">[SCOI2011]糖果</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>有 <script type="math/tex">n \ (n <= 100000)</script> 个点， <script type="math/tex">k \ (k <= 100000)</script> 种关系。</p><p>有 <script type="math/tex">5</script> 种关系类型。</p><ul><li><script type="math/tex; mode=display">W_{A} == W_{B}</script></li><li><script type="math/tex; mode=display">W_{A} < W_{B}</script></li><li><script type="math/tex; mode=display">W_{A} >= W_{B}</script></li><li><script type="math/tex; mode=display">W_{A} > W_{B}</script></li><li><script type="math/tex; mode=display">W_{A} <= W_{B}</script></li></ul><p>找出满足关系的最小总权值。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h4><p>裸的差分约束。<br>分类讨论：</p><ul><li><script type="math/tex; mode=display">W_{A} == W_{B} \rightarrow (a - b >= 0 \ and \ b - a >= 0) \rightarrow (edge_{b \rightarrow a} = 0, edge_{a \rightarrow b} = 0)</script></li><li><script type="math/tex; mode=display">W_{A} < W_{B} \rightarrow (b - a > 0 \rightarrow b - a >= 1) \rightarrow (edge_{a \rightarrow b} = 1)</script></li><li><script type="math/tex; mode=display">W_{A} >= W_{B} \rightarrow (a - b >= 0) \rightarrow (edge_{b \rightarrow a} = 0)</script></li><li><script type="math/tex; mode=display">W_{A} > W_{B} \rightarrow (a - b > 0 \rightarrow a - b >= 1) \rightarrow (edge_{b \rightarrow a} = 1)</script></li><li><script type="math/tex; mode=display">W_{A} <= W_{B} \rightarrow (b - a >= 0) \rightarrow (edge_{a \rightarrow b} = 0)</script></li></ul><p>由于每个点都权值至少为 $1$ ，所以 <script type="math/tex">edge_{S \rightarrow i} = 1</script> 。<br>跑最长路即可。<br>时间复杂度： <script type="math/tex">O(qk)</script> 。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">3e5</span> + <span class="number">10</span>, kmax_int = <span class="number">0x3f3f3f3f</span>, kmod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foe(x, y)  for(REG int (x) = head[(y)]; (x); (x) = edges[i].l)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SPFA</span>  &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, d, l;</span><br><span class="line">  &#125;  edges[kmax_num];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> head[(<span class="keyword">int</span>)<span class="number">1e5</span> + <span class="number">10</span>], cnt;</span><br><span class="line">  <span class="keyword">int</span> dist[(<span class="keyword">int</span>)<span class="number">1e5</span> + <span class="number">10</span>];</span><br><span class="line">  <span class="keyword">int</span> sum[(<span class="keyword">int</span>)<span class="number">1e5</span> + <span class="number">10</span>];</span><br><span class="line">  <span class="keyword">bool</span> vis[(<span class="keyword">int</span>)<span class="number">1e5</span> + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(REG <span class="keyword">int</span> u, REG <span class="keyword">int</span> v, REG <span class="keyword">int</span> d)</span>  </span>&#123;</span><br><span class="line">    edges[++cnt] = (Edge) &#123;v, d, head[u]&#125;;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Solve</span><span class="params">(REG <span class="keyword">int</span> num)</span>  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;  <span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>.push(num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    vis[num] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::fill(dist, dist + n + <span class="number">1</span>, <span class="number">-1e9</span>);</span><br><span class="line">    dist[num] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    REG <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())  &#123;</span><br><span class="line">      u = <span class="built_in">queue</span>.front();  <span class="built_in">queue</span>.pop();</span><br><span class="line">      vis[u] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(sum[u] == n + <span class="number">1</span>)  &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      foe(i,u)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[edges[i].v] &lt; dist[u] + edges[i].d)  &#123;</span><br><span class="line">          dist[edges[i].v] = dist[u] + edges[i].d;</span><br><span class="line">          <span class="keyword">if</span>(!vis[edges[i].v])  &#123;</span><br><span class="line">            <span class="built_in">queue</span>.push(edges[i].v);</span><br><span class="line">            vis[edges[i].v] = <span class="number">1</span>;</span><br><span class="line">            ++sum[edges[i].v];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  spfa;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">int</span> cmd, a, b;</span><br><span class="line">  FOR(i,<span class="number">0</span>,m)  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cmd &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(cmd == <span class="number">1</span>)  spfa.AddEdge(a, b, <span class="number">0</span>),  spfa.AddEdge(b, a, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">if</span>(cmd == <span class="number">2</span>)  spfa.AddEdge(a, b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">if</span>(cmd == <span class="number">3</span>)  spfa.AddEdge(b, a, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">if</span>(cmd == <span class="number">4</span>)  spfa.AddEdge(b, a, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">if</span>(cmd == <span class="number">5</span>)  spfa.AddEdge(a, b, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(cmd == <span class="number">2</span> || cmd == <span class="number">4</span>)  <span class="keyword">if</span>(a == b)  &#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>);  <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  For(i,1,n)  spfa.AddEdge(0, i, 1);</span></span><br><span class="line">  <span class="keyword">for</span>(REG <span class="keyword">int</span> i = n; i ; --i)  spfa.AddEdge(<span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!spfa.Solve(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">  For(i,<span class="number">1</span>,n)  ans += spfa.dist[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>最后面向源点加边时不知道为什么正着加会被卡掉 <script type="math/tex">QAQ</script> ，所以就倒着加了。</li></ul>]]></content>
      
      <categories>
          
          <category> 各省省选 </category>
          
          <category> SCOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 差分约束 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[SDOI2005] 阶梯教室设备利用</title>
      <link href="//SDOI2005-%E9%98%B6%E6%A2%AF%E6%95%99%E5%AE%A4%E8%AE%BE%E5%A4%87%E5%88%A9%E7%94%A8/"/>
      <url>//SDOI2005-%E9%98%B6%E6%A2%AF%E6%95%99%E5%AE%A4%E8%AE%BE%E5%A4%87%E5%88%A9%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.luogu.org/problemnew/show/2439" target="_blank" rel="noopener">[SDOI2005] 阶梯教室设备利用</a></p><h4 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h4><p>有 <script type="math/tex">n \ (n <= 10000)</script> 个演讲，一次只能举行 <script type="math/tex">1</script> 个。</p><p>某一演讲结束的瞬间可以立即开始另一个演讲。</p><p>计算最大的可能演讲总时间。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><p>转移方程显而易见（设开始为 $l$ ，结束为 $r$ ）：</p><script type="math/tex; mode=display">f[r] = std::max(f[r],  \ f[i] + r - l) \ (i  \in [0, l])</script><p>问题是不好转移啊2333。<br>考虑用线段树维护最大值。<br>单点更新，区间求最大值即可。<br>时间复杂度： <script type="math/tex">O(nlogn)</script> 。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(x,y,z) for (REG int (x) = (y); (x) &lt;  (z); ++(x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kmax_num = <span class="number">3e4</span> + <span class="number">10</span>, kmax_int = <span class="number">2147483647</span>, kmod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;  t[kmax_num];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val[kmax_num &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> lson (root &lt;&lt; 1)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> rson (root &lt;&lt; 1) | 1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(REG <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    val[root] = <span class="built_in">std</span>::max(val[lson], val[rson]);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(REG <span class="keyword">int</span> root, REG <span class="keyword">int</span> begin, REG <span class="keyword">int</span> end, REG <span class="keyword">int</span> udp_begin, REG <span class="keyword">int</span> udp_end, REG <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(udp_begin &lt;= begin &amp;&amp; udp_end &gt;= end) &#123;</span><br><span class="line">      val[root] = <span class="built_in">std</span>::max(val[root], num);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      REG <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(udp_begin &lt;= mid)  Update(lson, begin, mid, udp_begin, udp_end, num);</span><br><span class="line">      <span class="keyword">if</span>(udp_end &gt; mid)     Update(rson, mid + <span class="number">1</span>, end, udp_begin, udp_end, num);</span><br><span class="line">      PushUp(root);</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(REG <span class="keyword">int</span> root, REG <span class="keyword">int</span> begin, REG <span class="keyword">int</span> end, REG <span class="keyword">int</span> que_begin, REG <span class="keyword">int</span> que_end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(que_begin &lt;= begin &amp;&amp; que_end &gt;= end) &#123;</span><br><span class="line">      <span class="keyword">return</span> val[root];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      REG <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>, ans = <span class="number">-0x7fffffff</span>;</span><br><span class="line">      <span class="keyword">if</span>(que_begin &lt;= mid)  ans = <span class="built_in">std</span>::max(ans, Query(lson, begin, mid, que_begin, que_end));</span><br><span class="line">      <span class="keyword">if</span>(que_end &gt; mid)     ans = <span class="built_in">std</span>::max(ans, Query(rson, mid + <span class="number">1</span>, end, que_begin, que_end));</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">undef</span> lson</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">undef</span> rson</span></span><br><span class="line">&#125; segment_tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  REG <span class="keyword">int</span> l, r;</span><br><span class="line">  FOR(i,<span class="number">0</span>,n)  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r, t[i].first = l, t[i].second = r;</span><br><span class="line">  sort(t, t + n);</span><br><span class="line"></span><br><span class="line">  FOR(i,<span class="number">0</span>,n)  &#123;</span><br><span class="line">    l = t[i].first, r= t[i].second;</span><br><span class="line">    f[r] = <span class="built_in">std</span>::max(f[r], segment_tree.Query(<span class="number">1</span>, <span class="number">0</span>, kmax_num - <span class="number">1</span>, <span class="number">0</span>, l) + r - l);</span><br><span class="line">    segment_tree.Update(<span class="number">1</span>, <span class="number">0</span>, kmax_num - <span class="number">1</span>, r, r, f[r]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, segment_tree.Query(<span class="number">1</span>, <span class="number">0</span>, kmax_num - <span class="number">1</span>, <span class="number">0</span>, kmax_num - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>这里记录开始和结束用了 <script type="math/tex">std::pair</script> 实现，<script type="math/tex">std::pair</script> 大法好！</li><li><del>根本不需要 <script type="math/tex">std::pair</script> 好不好！可以直接用两个数组实现！</del></li></ul>]]></content>
      
      <categories>
          
          <category> 各省省选 </category>
          
          <category> SDOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
